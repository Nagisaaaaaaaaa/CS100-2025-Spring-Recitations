/*

  ! Baseline:
  ! 1. Read the following story and understand it.

*/

#include <iostream>
#include <vector>

// 《第一章：关于邻家的引用传参大人不知不觉把我惯成废人这件事》

// 我们知道，如果在C语言中想要通过一个函数去修改某个变量的值
// 直接传递这个变量本身是不可行的，因为会发生【拷贝】
// 我们的一通组合拳可能全部打在了 <我们传入的变量> 的克隆体上

// 所以我们当时的解决方法是：偷偷把地址递给函数，让函数在内部开盒它

int c_style_addone(int *xptr) {
  // 收到一份地址，然后过去开盒住在里面的人
  // 本质上发生了： int * xptr = <用户传入的变量地址> 这样的地址拷贝
  return ++(*xptr);
}

// 但是这种写法带来了很多的丑陋的、非必要的指针操作
// 这时候我们就可以通过reference来优化我们的参数传递

int cpp_style_addone(int &xref) {
  // 直接把要找的人传唤过来，当面对质
  // 本质上发生了 int & xref = <用户传入的变量> 这样的绑定
  // 所以xref 只是 <用户传入的变量> 在此scope中的别名而已
  // 本质上是同一件东西
  return ++xref;
}

// 类似的事情发生在我们新学的range-based循环中：

void each_add_one(std::vector<int> &vec) {
  for (auto &x : vec) {
    ++x;
  }
  // 注意到这里出现了两处&
  // 第一处在参数列表，它确保我们直接访问传入的vec本体（而非它的克隆兄弟）
  // 第二处在循环控制处，它确保我们每次访问的是vec本体里的元素（而非它们的克隆兄弟）
}

int main() {

  int x = 42;

  // 在下面这个例子中，我们事实上对地址这个“值”进行了一次拷贝
  std::cout << c_style_addone(&x) << "\n"; // &x作为孤魂野鬼，把x的家庭住址告诉函数后就安息了
  // 然后在函数内部，xptr作为局部的有名有姓的人物，通过【拷贝】获得了孤魂野鬼带来的信息
  // 但是在离开了这个scope之后，xptr也被“扫进了历史的垃圾堆”
  // 在被扫进垃圾堆之前，他白帝托孤，通过【拷贝】把 ++(*xptr) 的值托付（返回）给了调用处
  // 而这个值，即 c_style_addone(&x) 作为表达式的值，同样是一个孤魂野鬼（右值）
  // 在完成历史使命（输出到终端）的任务后，很快就消亡了

  // 而下面这个例子则有些不同，通过【引用】，我们（至少在“表面上”）直接把x传递给了函数内部
  std::cout << cpp_style_addone(x) << "\n"; // 不再需要&x这个右值来充当斥候

  return 0;
}
