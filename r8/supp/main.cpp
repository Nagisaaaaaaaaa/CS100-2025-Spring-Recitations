/*

  * Bonus:
  * 1. 为什么在 Python 如此火热的今天，我们要学习 C++ 这门编译型语言？
  *    有没有什么事情是只有编译型语言能做到的？
  * 2. 如何使用 ARIA::Tec，在编译时做表达式化简？

*/

#include "ARIA/Tup.h"

using namespace ARIA;

int main() {
  // 《编译器大小姐想帮我化简～天才们的编程头脑战～》

  // 我们想用 C++ 计算叉乘：
  //   a = (x, 0, 0),
  //   b = (0, y, 0),
  //   c = a × b.
  // 通过一些简单计算，我们化简得到 c = (0, 0, x * y)。
  // 但手动化简还是太累了呀，我们能不能请编译器帮我们化简呢？
  double x, y;
  std::cin >> x >> y;

  // 编译器：“在我看来，x，y，和 0，都是 double，是完全一样的东西。”
  // 编译器：“所以就算你知道 a 和 b 中分别有两个 0，我也不知道呀。”
  // 编译器：“要不，我们约定一个记号，用某个‘特定类型’来表示 0？”
  //
  // 于是我们和编译器约定了：C<0.0>，这个神秘类型，就是 “0 的类型”，
  // 它对应的变量，_0，就可以拿来当作我们和编译器约定的记号。
  //   注：这里 C 的意思是 constant.
  C<0.0> _0;

  // 我们把约定的记号，_0，悄悄塞进向量 a 和 b。
  //   注：这里 Tec 的意思是 tuple-like vector.
  Tec a{x, _0, _0};
  Tec b{_0, y, _0};

  // 这样一来，做叉乘的时候，编译器就能帮我们化简了呢。
  Tec c = Cross(a, b);

  // 首先，编译器写出了叉乘的数学公式：
  //   (a1 * b2 - a2 * b1,
  //    a2 * b0 - a0 * b2,
  //    a0 * b1 - a1 * b0).
  //
  // 接着，通过约定的记号，_0，编译器知道里面有很多 0：
  //   ( 0 *  0 -  0 * b1,
  //     0 *  0 - a0 *  0,
  //    a0 * b1 -  0 *  0).
  //
  // 然后，编译器消掉了很多不需要计算的项：
  //   (0,
  //    0,
  //    a0 * b1).
  //
  // 最后，编译器完成了编译：
  //   1. c 的前两个元素都是 0，第三个元素是 a0 * b1，超简单的。
  //   2. 既然前两个元素都是 0，那就返回约定的记号吧。

  // 来看看叉乘得到的 c 是什么吧！
  std::cout << "a: " << a << std::endl;
  std::cout << "b: " << b << std::endl;
  std::cout << "c: " << c << std::endl;

  return 0;
}
