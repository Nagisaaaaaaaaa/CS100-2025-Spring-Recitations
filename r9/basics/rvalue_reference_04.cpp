#include <iostream>

//? 《右值终末旅行》第二季

void Print(const std::string &str) {
  std::cout << str + "!" << std::endl;
}

//! 一切的根源都是重载导致的 ambiguity。
//! 为了绕开这个问题，
//! C++ 设计师引入了 右值引用 (r-value reference) 这个东西。
//!
//! 我们把 std::string 改成 std::string &&，
//! std::string && 就是一个 右值引用“类型”。
//!
//! 右值引用 也是一种引用，但它只能接收右值，不能接收左值。
//! 所以当传入左值时，调用的永远是隔壁重载。
void Print(std::string &&str) {
  str += "!";
  std::cout << str << std::endl;
}

int main() {
  // 那我问你，这里会调用哪个重载？
  std::string str("QAQ");
  Print(str);

  // 答案：
  // 会调用第一个，因为
  //! 右值引用 只能接收右值，不能接收左值。

  // 那我问你，这里会调用哪个重载？
  Print(std::string("QAQ"));

  // 答案：
  // 会调用第二个，因为
  //! C++ 设计师为 右值引用 开了个后门，
  //! 虽然 const & 也能接收右值，但 && 总是拥有更高的优先级，
  //! (在右值眼中，&& 拥有更高的江湖地位)。

  // 分析一波 Print(std::string("QAQ")) 发生了什么？
  //  1. std::string("QAQ") 是个右值 (孤魂野鬼)。
  //! 2. Print 接收 &&，
  //!    和 const & 一样，&& 也能延长右值的生命周期，
  //!    所以，变量 str 延长了 std::string("QAQ") 的生命周期。

  //! 所以，右值引用不是什么神秘的东西，我们只需要记住这几条游戏规则：
  //! 1. 选择函数重载时，右值引用的优先级更高 (开后门)。
  //! 2. 右值引用只能接收右值，不能接收左值。
  //! 3. 与 const & 类似地，右值引用也能延长右值的生命周期。
  //! 4. 与 const & 的延长生命周期不同，右值引用不要求 const。

  //* 当我们希望根据接收左值还是右值，做不同事情的时候，
  //* 99% 的时候，我们需要实现 const & 和 && 两个版本。
  //*
  //* 这时候我们就能够理解，为什么：
  //* 1. 拷贝构造/赋值 函数的参数是 const &，
  //* 2. 移动构造/赋值 函数的参数是 &&，

  return 0;
}
